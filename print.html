<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command Line Applications in Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/special-content.css">
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index.html">Getting started</a></li><li><a href="tutorial/index.html"><strong aria-hidden="true">1.</strong> A command line app in 15 minutes</a></li><li><ol class="section"><li><a href="tutorial/setup.html"><strong aria-hidden="true">1.1.</strong> Project setup</a></li><li><a href="tutorial/cli-args.html"><strong aria-hidden="true">1.2.</strong> Parsing command line arguments</a></li><li><a href="tutorial/impl-draft.html"><strong aria-hidden="true">1.3.</strong> First implementation</a></li><li><a href="tutorial/errors.html"><strong aria-hidden="true">1.4.</strong> Nicer error reporting</a></li><li><a href="tutorial/output.html"><strong aria-hidden="true">1.5.</strong> Output for humans and machines</a></li><li><a href="tutorial/testing.html"><strong aria-hidden="true">1.6.</strong> Testing</a></li><li><a href="tutorial/packaging.html"><strong aria-hidden="true">1.7.</strong> Packaging and distributing a Rust tool</a></li></ol></li><li><a href="in-depth/index.html"><strong aria-hidden="true">2.</strong> In-depth topics</a></li><li><ol class="section"><li><a href="in-depth/signals.html"><strong aria-hidden="true">2.1.</strong> Signal handling</a></li><li><a href="in-depth/config-files.html"><strong aria-hidden="true">2.2.</strong> Using config files</a></li><li><a href="in-depth/exit-code.html"><strong aria-hidden="true">2.3.</strong> Exit codes</a></li><li><a href="in-depth/human-communication.html"><strong aria-hidden="true">2.4.</strong> Communicating with humans</a></li><li><a href="in-depth/machine-communication.html"><strong aria-hidden="true">2.5.</strong> Communicating with machines</a></li><li><a href="in-depth/docs.html"><strong aria-hidden="true">2.6.</strong> Rendering documentation for you CLI apps</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Command Line Applications in Rust</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#command-line-apps-in-rust" id="command-line-apps-in-rust"><h1>Command line apps in Rust</h1></a>
<p>Rust is a statically compiled, fast language with great tooling and a rapidly growing ecosystem.
That makes it a great fit for writing command line applications:
They should be small, portable, and quick to run.
Command line applications are also a great way to get started with learning Rust;
or if you want to introduce Rust to your team!</p>
<p>Writing a program with a simple command line interface (CLI)
is great a exercise for a beginner
who is new to the language and wants to get a feel for it.
There are many aspects to this topic, though,
that often only reveal themselves later on.</p>
<p>This book is structure like this:
We start with a quick tutorial,
after which you’ll end up with a working CLI tool.
You’ll be exposed to a few of the core concepts of Rust
as well as the main aspects of CLI applications.
What follows are chapters that go into more detail
on some of these aspects.</p>
<p>One last thing before we dive right into CLI applications:
If you found an error in this book
or want to help us write more content for it,
you can find its source <a href="https://github.com/rust-lang-nursery/cli-wg">in the CLI WG repository</a>.
We’d love to hear your feedback!
Thank you!</p>
<a class="header" href="print.html#learning-rust-by-writing-a-command-line-app-in-15-minutes" id="learning-rust-by-writing-a-command-line-app-in-15-minutes"><h1>Learning Rust by Writing a Command Line App in 15 Minutes</h1></a>
<p>This short tutorial will guide you through writing
a CLI (command line interface) application
in <a href="https://rust-lang.org/">Rust</a>.
It will take you roughly fifteen minutes;
but feel free to skip parts you don’t need to know right now
or jump in at any point.
You’ll learn all the essentials about how to get going,
and where to find more information.</p>
<aside>
<p><strong>Prerequisites:</strong>
This tutorial does not replace a general introduction to programming,
and expects you to be familiar with a few common concepts.
You should be comfortable with using a command line/terminal.
If you already know a few other languages,
this can be a good first contact with Rust.</p>
<p><strong>Getting help:</strong>
If you at any point feel overwhelmed or confused with the features used,
have a look at the extensive official documentation that comes with Rust,
first and foremost the book,
The Rust Programming Language.
It comes with most Rust installations
(<code>rustup doc</code>),
and is available online on
<a href="https://doc.rust-lang.org">doc.rust-lang.org</a>.</p>
<p>You are also very welcome to ask questions –
the Rust community is known to be friendly and helpful.
Have a look at the
<a href="https://www.rust-lang.org/en-US/community.html">community page</a>
to see a list of places where people discuss Rust.</p>
</aside>
<p>What kind of project do you want to write?
How about we start with something simple:
Let’s write a small <code>grep</code> clone.
That is a tool that we can give a string and a path
and it’ll print only the lines that contain the given string.
Let’s call it <code>grrs</code> (pronounced “grass”).</p>
<p>In the end,
we want to be able to run our tool like this:</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[some help text explaining the available options]
</code></pre>
<aside class="note">
<p><strong>Note:</strong>
This book is written for <a href="https://rust-lang-nursery.github.io/edition-guide/">Rust 2018</a>.
The code examples can also be used on Rust 2015,
but you might need to tweak them a bit;
add <code>extern crate foo;</code> invocations, for example.</p>
<p>At the time of this writing,
to use Rust 2018 you have to use a nightly compiler version.
Enable it by adding <code>edition = &quot;2018&quot;</code>
to the <code>[package]</code> section of your <code>Cargo.toml</code> file
(as well as write <code>cargo-features = [&quot;edition&quot;]</code> at the top of it).</p>
</aside>
<a class="header" href="print.html#project-setup" id="project-setup"><h1>Project setup</h1></a>
<p>If you haven’t already,
<a href="https://www.rust-lang.org/install.html">install Rust</a> on your computer
(it should only take a few minutes).
After that, open a terminal and navigate to the directory
you want to put your application code into.</p>
<p>If you’ve already seen the basic Rust tutorials,
you might be inclined to start with <code>cargo new my-cool-app</code>.
To save us some time,
we’ll instead start with a CLI-specific template:
<code>cargo generate --git https://github.com/rust-clique/cargo-template-cli</code>.
When you run this, it’ll ask you for a project name
(please enter “grrs”).</p>
<aside class="todo">
<p><strong>TODO:</strong>
Create this template!
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/53">Issue #53</a></p>
</aside>
<p>If look at the newly created <code>grrs</code> directory,
you’ll find a typical setup for a Rust project:</p>
<ul>
<li>A <code>Cargo.toml</code> file that contains metadata for our project,
incl. a list of dependencies/external libraries we use.</li>
<li>A <code>src/main.rs</code> file that is the entry point for our (main) binary.</li>
<li>A <code>tests/</code> directory that will contain integration tests for our tool.</li>
</ul>
<p>If you can execute <code>cargo run</code> in the <code>grrs</code> directory
and see it greet you, you’re all set up.</p>
<a class="header" href="print.html#what-it-might-look-like" id="what-it-might-look-like"><h2>What it might look like</h2></a>
<aside class="todo">
<p><strong>TODO:</strong>
Update asciinema to use cargo-generate.
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/53">Issue #53</a></p>
</aside>
<p><img src="./tutorial/setup.svg" alt="" /></p>
<a class="header" href="print.html#parsing-command-line-arguments" id="parsing-command-line-arguments"><h1>Parsing command line arguments</h1></a>
<p>A typical invocation of our CLI tool will look like this:
<code>grrs foobar test.txt</code>.
We expect our program to look at <code>test.txt</code>
and print out the lines that contain <code>foobar</code>.
But how do we get these two values?</p>
<p>The text after the name of the program is often called
the “command line arguments”,
or “command line flags”
(especially when they look like <code>--this</code>).
Internally, the operating system usually represents them
as a list of strings --
roughly speaking, the get separated by spaces.
There are many ways to think about these arguments,
and how to parse them
into something more easy to work with.
You will also need to tell the users of your program
which arguments they need to give
and in which format they are expected.</p>
<a class="header" href="print.html#cli-arguments-as-data-type" id="cli-arguments-as-data-type"><h2>CLI Arguments as data type</h2></a>
<p>Instead of thinking about them as a bunch of text,
it often pays off to think of CLI arguments as a custom data type
that represents the inputs to your program.</p>
<p>Look at <code>grrs foobar test.txt</code>:
There are two arguments,
first the <code>pattern</code> (the string to look for),
and then the <code>path</code> (the file to look in).</p>
<p>What more can we say about them?
Well, for a start, both are required.
We haven’t talked about any default values,
so we expect our users to always provide two values.
Further more, we can say a bit about their types:
The pattern is expected to be a string,
while the second argument is expect to be path to a file.</p>
<p>In Rust, it is very common to structure programs around the data they deal with
so this way of looking at CLI arguments fits very well.
Let’s start with this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}
#}</code></pre></pre>
<p>This defines a new structure (a <a href="https://doc.rust-lang.org/1.27.2/book/second-edition/ch05-00-structs.html"><code>struct</code></a>)
that has two fields to store data in: <code>pattern</code>, and <code>path</code>.</p>
<aside>
<p><strong>Aside:</strong>
<a href="https://doc.rust-lang.org/1.27.2/std/path/struct.PathBuf.html"><code>PathBuf</code></a> is like a <a href="https://doc.rust-lang.org/1.27.2/std/string/struct.String.html"><code>String</code></a> but for file system paths that works cross-platform.</p>
</aside>
<p>Now, we still need to get the actual arguments our program got into this form.
One option would be manually parse the list of strings we get from the operating system
and build the structure ourselves.
It would looks something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
let args = Cli {
    pattern: pattern,
    path: std::path::PathBuf::from(path),
};
#}</code></pre></pre>
<p>This works, but it’s not very convenient.
How would you deal with the requirement to support
<code>--pattern=&quot;foo&quot;</code> or <code>--pattern &quot;foo&quot;</code>?
How would you implement <code>--help</code>?</p>
<a class="header" href="print.html#parsing-cli-arguments-with-clap" id="parsing-cli-arguments-with-clap"><h2>Parsing CLI Arguments with Clap</h2></a>
<p>A much nicer way is to use one of the many available libraries.
The most popular library for parsing command line arguments
is called <a href="https://clap.rs/"><code>clap</code></a>.
It has all the functionality you’d expect,
including support for sub-commands, shell completions, and great help messages.
The <a href="https://docs.rs/structopt"><code>structopt</code></a> library builds on <code>clap</code>
and provides a “derive” macro
to generate <code>clap</code> applications.</p>
<p>This is quite nice:
All we have to do is annotate a struct
and it’ll generate the code that parses the arguments into the fields.
Let’s add our fields to the <code>Cli</code> struct in the template
and also write some documentation comments along the way.
It’ll look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use] extern crate structopt;
use std::path::PathBuf;
use structopt::StructOpt;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    #[structopt(parse(from_os_str))]
    path: std::path::PathBuf,
}
#}</code></pre></pre>
<aside class="node">
<p><strong>Note:</strong>
There are a lot of custom attributes you can add to fields.
For example,
we added one to tell structopt how to parse the <code>PathBuf</code> type.
To say you want to use this field for the argument after <code>-o</code> or <code>--output</code>,
you’d add <code>#[structopt(short = &quot;o&quot;, long = &quot;output&quot;)]</code>.
For more information,
see the <a href="https://docs.rs/structopt">structopt documentation</a>.</p>
</aside>
<aside class="todo">
<p><strong>TODO:</strong>
Ensure this works with clap3.
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/64">Issue #64</a></p>
</aside>
<p>Right below the <code>Cli</code> struct our template contains its <code>main</code> function.
When the program starts, it will call this function.
The first line is:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let args = Cli::from_args();
#}</code></pre></pre>
<p>This will try to parse the arguments into our <code>Cli</code> struct.</p>
<p>But what if that fails?
That’s the beauty of this approach:
Clap knows which fields to expect,
and what their expected format is.
It can automatically generate a nice <code>--help</code> message,
as well a give great errors
to suggest you pass <code>--output</code> when you wrote <code>--putput</code>.</p>
<aside class="note">
<p><strong>Note:</strong>
The <code>from_args</code> method is meant to be used in your <code>main</code> function.
When it fails,
it will print out an error or help message and exit the program.
Don’t use it in other places!</p>
</aside>
<a class="header" href="print.html#this-is-what-it-may-look-like" id="this-is-what-it-may-look-like"><h2>This is what it may look like</h2></a>
<p><img src="./tutorial/cli-args.svg" alt="" /></p>
<aside class="todo">
<p><strong>TODO:</strong>
Use clap 3!
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/64">Issue #64</a></p>
</aside>
<a class="header" href="print.html#first-implementation-of-grrs" id="first-implementation-of-grrs"><h1>First implementation of <code>grrs</code></h1></a>
<p>Right, now that we have our input data,
we can start to write our actual tool.
We’ll only work with <code>src/main.rs</code> for now.</p>
<aside class="shortcut">
<p><strong>Shortcut:</strong>
If you skipped the CLI argument parsing chapter,
you can put</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let path = &quot;test.txt&quot;;
let pattern = &quot;foo&quot;;
#}</code></pre></pre>
<p>at the top of your file
and replace <code>args.path</code> with <code>path</code>
and <code>args.pattern</code> with <code>pattern</code>
in the example code below.</p>
</aside>
<p>Let’s start by opening the file we got:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let content = std::fs::read_to_string(&amp;args.path)?;
#}</code></pre></pre>
<aside>
<p><strong>Aside:</strong>
If the file can’t be read,
the question mark operator (<code>?</code>)
will propagate the error and return from the function.
It basically turns the line into this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let content = match std::fs::read_to_string(&amp;args.path) {
    Ok(value) =&gt; value,
    Err(error) =&gt; return error,
};
#}</code></pre></pre>
<p>Read more about this in the
<a href="https://doc.rust-lang.org/1.27.2/book/second-edition/ch09-00-error-handling.html">error handling chapter of the Rust book</a>.</p>
</aside>
<p>Now, let’s iterate over the lines
and print each one that contains our pattern:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
#}</code></pre></pre>
<p>Give it a try: <code>cargo run -- main src/main.rs</code> should work now!</p>
<aside>
<p><strong>Aside:</strong>
This is probably not the best implementation,
as it will read the whole file into memory
– however large the file may be!
Feel free to optimize it!
(One idea might be to use a <a href="https://doc.rust-lang.org/1.27.0/std/io/struct.BufReader.html"><code>BufReader</code></a>
instead of <code>read_to_string()</code>.)</p>
</aside>
<a class="header" href="print.html#nicer-error-reporting" id="nicer-error-reporting"><h1>Nicer error reporting</h1></a>
<p>We all can do nothing but accept the fact that errors will occur.
And in contrast to many other languages,
it’s very hard not to notice and deal with this reality
when using Rust:
As it doesn’t have exceptions,
all possible error states are often encoded in the return types of functions.</p>
<a class="header" href="print.html#results" id="results"><h2>Results</h2></a>
<p>A function like <a href="https://doc.rust-lang.org/1.27.2/std/fs/fn.read_to_string.html"><code>read_to_string</code></a> doesn’t return a string.
Instead, it returns a <a href="https://doc.rust-lang.org/1.27.2/std/result/index.html"><code>Result</code></a>
that contains either
a <code>String</code>
or an error of some type
(in this case <a href="https://doc.rust-lang.org/1.27.2/std/io/type.Result.html"><code>std::io::Error</code></a>).</p>
<p>How do you know which it is?
Since <code>Result</code> is an <code>enum</code>,
you can use <code>match</code> to check which variant it is:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
let result = std::fs::read_to_string(&quot;test.txt&quot;);
match result {
    Ok(content) =&gt; { println!(&quot;File content: {}&quot;, content); }
    Err(error) =&gt; { println!(&quot;Oh noes: {}&quot;, error); }
}
# }
</code></pre></pre>
<aside>
<p><strong>Aside:</strong>
Not sure what enums are or how they work in Rust?
<a href="https://doc.rust-lang.org/1.27.2/book/second-edition/ch06-00-enums.html">Check this chapter of the Rust book</a>
to get up to speed.</p>
</aside>
<a class="header" href="print.html#unwrapping" id="unwrapping"><h2>Unwrapping</h2></a>
<p>Now, we were able to access content of the file,
but we can’t really do anything with it after the <code>match</code> block.
For this, we’ll need to somehow deal with the error case.
The challenge is that all arms of a <code>match</code> block need to return something of the same type.
But there’s a need trick to get around that:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!(&quot;Can't deal with {}, just exit here&quot;, error); }
};
println!(&quot;file content: {}&quot;, content);
# }
</code></pre></pre>
<p>We can use the String in <code>content</code> after the match block.
If <code>result</code> were an error, the String wouldn’t exist.
But since the program would exit before it ever reached a point where we use <code>content</code>,
it’s fine.</p>
<p>This may seem drastic,
but it’s very convenient.
If your program needs to read that file and can’t do anything if the file doesn’t exist,
exiting is a valid strategy.
There’s even a shortcut method on <code>Result</code>s, called <code>unwrap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let content = std::fs::read_to_string(&quot;test.txt&quot;).unwrap();
#}</code></pre></pre>
<a class="header" href="print.html#no-need-to-panic" id="no-need-to-panic"><h2>No need to panic</h2></a>
<p>Of course, aborting the program is not the only way to deal with errors.
Instead of the <code>panic!</code>, we can also easily write <code>return</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error); }
};
println!(&quot;file content: {}&quot;, content);
# Ok(())
# }
</code></pre></pre>
<p>This, however changes the return type our function needs.
Indeed, there was something hidden in our examples all this time:
The function signature this code lives in.
And in this last example with <code>return</code>,
it becomes important.
Here’s the <em>full</em> example:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string(&quot;test.txt&quot;);
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error); }
    };
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>Our return type is a <code>Result</code>!
This is why we can write <code>return Err(error);</code> in the second match arm.
See how there is an <code>Ok(())</code> at the bottom?
It’s the default return value of the function and means
“Result is okay, and has no content”.</p>
<aside>
<p><strong>Aside:</strong>
Why is this not written as <code>return Ok(());</code>?
It easily could be – this is totally valid as well.
The last expression of any block in Rust is its return value,
and it is customary to omit needless <code>return</code>s.</p>
</aside>
<a class="header" href="print.html#question-mark" id="question-mark"><h2>Question Mark</h2></a>
<p>Just like calling <code>.unwrap()</code> is a shortcut
for the <code>match</code> with <code>panic!</code> in the error arm,
we have another shortcut for the <code>match</code> that <code>return</code>s in the error arm:
<code>?</code>.</p>
<p>Thats’s right, a question mark.
You can append this operator to a value of type <code>Result</code>,
and Rust will internally expand this to something very similar to
the <code>match</code> we just wrote.</p>
<p>Give it a try:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string(&quot;test.txt&quot;)?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>Very concise!</p>
<aside>
<p><strong>Aside:</strong>
There are a few more things happening here,
that are not required to understand to work with this.
For example,
the error type in our <code>main</code> function is <code>Box&lt;dyn std::error::Error&gt;</code>.
But we’ve above seen that <code>read_to_string</code> returns a <a href="https://doc.rust-lang.org/1.27.2/std/io/type.Result.html"><code>std::io::Error</code></a>.
This works because <code>?</code> actually expands to code to <em>convert</em> error types.</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code> is also an interesting type.
It’s a <code>Box</code> that can contain <em>any</em> type
that implements the standard <a href="https://doc.rust-lang.org/1.27.2/std/error/trait.Error.html"><code>Error</code></a> trait.
This means that basically all errors can be put into this box,
so we can use <code>?</code> on all of the usual functions that return <code>Result</code>s.</p>
</aside>
<a class="header" href="print.html#providing-context" id="providing-context"><h2>Providing Context</h2></a>
<p>The errors you get when using <code>?</code> in your <code>main</code> function are okay,
but great they are not.
For example:
When you run <code>std::fs::read_to_string(&quot;test.txt&quot;)?</code>
but the file <code>test.txt</code> doesn’t exist,
you get this output:</p>
<blockquote>
<p>Error: Os { code: 2, kind: NotFound, message: “No such file or directory” }</p>
</blockquote>
<p>In cases where your code doesn’t literally contain the file name,
it’d be very hard to tell which file was <code>NotFound</code>.
There are multiple ways to deal with this.</p>
<p>For example, we can create our own error type,
and then use that to build a custom error message:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!(&quot;Error reading `{}`: {}&quot;, path, err)))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>Now,
running this we’ll get our custom error message:</p>
<blockquote>
<p>Error: CustomError(”Error reading <code>test.txt</code>: No such file or directory (os error 2)”)</p>
</blockquote>
<p>Not very pretty,
but we can easily adapt the debug output for our type later on.</p>
<p>This pattern is in fact very common.
It has one problem, though:
We don’t store the original error,
only its string representation.
The often used <a href="https://docs.rs/failure"><code>failure</code></a> library has a neat solution for that:
Similar to our <code>CustomError</code> type,
it has a <a href="https://docs.rs/failure/0.1.3/failure/struct.Context.html"><code>Context</code></a> type
that contains a description as well as the original error.
The library also brings with it an extension trait (<a href="https://docs.rs/failure/0.1.3/failure/trait.ResultExt.html"><code>ResultExt</code></a>)
that adds <a href="https://docs.rs/failure/0.1.3/failure/trait.ResultExt.html#tymethod.context"><code>context()</code></a> and <a href="https://docs.rs/failure/0.1.3/failure/trait.ResultExt.html#tymethod.with_context"><code>with_context()</code></a> methods to <code>Result</code>.</p>
<p>To turn these wrapped error types
into something that humans will actually want to read,
we can further add the <a href="https://docs.rs/exitfailure"><code>exitfailure</code></a> crate,
and use its type as the return type of our <code>main</code> function.
The full example will then look like this:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate failure;
extern crate exitfailure;

use failure::ResultExt;
use exitfailure::ExitFailure;

fn main() -&gt; Result&lt;(), ExitFailure&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .with_context(|_| format!(&quot;could not read file `{}`&quot;, path))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>This will print an error like this:</p>
<blockquote>
<p>Error: could not read file <code>test.txt</code><br />
Info: caused by No such file or directory (os error 2)</p>
</blockquote>
<a class="header" href="print.html#output" id="output"><h1>Output</h1></a>
<a class="header" href="print.html#printing-hello-world" id="printing-hello-world"><h2>Printing “Hello World”</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;Hello World&quot;);
#}</code></pre></pre>
<p>Well, that was easy.
Great, onto the next topic.</p>
<a class="header" href="print.html#using-println" id="using-println"><h2>Using println</h2></a>
<p>You can pretty much print all the things you like
with the <code>println!</code> macro.
This macro has some pretty amazing capabilities,
but also a special syntax.
It expects you to write a string literal as the first parameter,
that contains placeholders that will be filled in
by the values of the parameters that follow as further arguments.</p>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
#}</code></pre></pre>
<p>will print</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>The curly braces (<code>{}</code>) in the string above is one of these placeholders.
This is the default placeholder type
that tries to print the given value in a human readable way.
For numbers and strings this works very well,
but not all types can do that.
This is why there is also a “debug representation”,
that you can get by filling the braces of the placeholder like this: <code>{:?}</code>.</p>
<p>For example,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
#}</code></pre></pre>
<p>will print</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>If you want your own data types to be printable for debugging and logging,
you can in most cases add a <code>#[derive(Debug)]</code> above their definition.</p>
<aside>
<p><strong>Aside:</strong>
“User-friendly” printing is done using the <a href="https://doc.rust-lang.org/1.27.2/std/fmt/trait.Display.html"><code>Display</code></a> trait,
debug output (human-readable but targeted at developers) uses the <a href="https://doc.rust-lang.org/1.27.2/std/fmt/trait.Debug.html"><code>Debug</code></a> trait.
You can find more information about the syntax you can use in <code>println!</code>
in the <a href="https://doc.rust-lang.org/1.27.2/std/fmt/index.html">documentation for the <code>std::fmt</code> module</a>.</p>
</aside>
<a class="header" href="print.html#printing-errors" id="printing-errors"><h2>Printing errors</h2></a>
<p>Printing errors should be done via <code>stderr</code>
to make it easier for users
and other tools
to pipe their outputs to files
or more tools.</p>
<aside>
<p><strong>Aside:</strong>
On most operating systems,
a program can write to two output streams, <code>stdout</code> and <code>stderr</code>.
<code>stdout</code> is for the program’s actual output,
while <code>stderr</code> allows errors and other messages to be kept separate from <code>stdout</code>.
That way,
output can be stored to a file or piped to another program
while errors are shown to the user.</p>
</aside>
<p>In Rust this is achieved
with <code>println!</code> and <code>eprintln!</code>,
the former printing to <code>stdout</code>
and the latter to <code>stderr</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
#}</code></pre></pre>
<aside>
<p><strong>Beware</strong>: Printing escape codes can be dangerous,
putting the user’s terminal into a weird state.
Always be careful when manually printing them!</p>
<p>Ideally you should be using a crate like <code>ansi_term</code>
when dealing with raw escape codes
to make your (and your user’s) life easier.</p>
</aside>
<a class="header" href="print.html#a-note-on-printing-performance" id="a-note-on-printing-performance"><h2>A note on printing performance</h2></a>
<p>Printing to the terminal is surprisingly slow!
If you call things like <code>println!</code> in a loop,
it can easily become a bottleneck in an otherwise fast program.
To speed this up,
there’s two things you can do.</p>
<p>First,
it helps to acquire a lock on <code>stdout</code> (or <code>stderr</code>)
and use <code>writeln!</code> to print to it directly.
This prevents the system from locking an unlocking <code>stdout</code> over and over again.</p>
<p>Second,
you might want to reduce the number of writes
you actually “flush” to the terminal.
<code>println!</code> tells the system to write to the terminal <em>every</em> time,
because it is usual to print each new line.
If you don’t need that,
you can wrap your <code>stdout</code> handle in a <a href="https://doc.rust-lang.org/1.29.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a>
which by default buffers up to 8kB.
(You can still call <code>.flush()</code> on this <code>BufWriter</code>
when you want to print immediately.)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let handle = stdout.lock(); // acquire a lock on it
let mut handle = io::BufWriter::new(handle); // optional: wrap that handle in a buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
#}</code></pre></pre>
<a class="header" href="print.html#showing-a-progress-bar" id="showing-a-progress-bar"><h2>Showing a progress bar</h2></a>
<p>Some CLI applications run less than a second,
others take minutes or hours.
If you are writing one of the latter types of programs,
you might want to show the user that something is happening.
For this, you should try to printing useful status updates,
ideally in a form that can be easily consumed.</p>
<p>Using the <a href="https://crates.io/crates/indicatif">indicatif</a> crate,
you can add progress bars
and little spinners to your program.</p>
<aside class="todo">
<p><strong>TODO:</strong>
Show an example like
<a href="https://github.com/mitsuhiko/indicatif/blob/950091d1b1683a88e01c4d4975f591009f56322b/examples/log.rs">this</a>
or <a href="https://github.com/ashleygwilliams/cargo-generate/blob/c18cba0b33764012e25288d43c6a8545222b96f4/src/main.rs#L95">this</a>.
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/67">Issue #67</a></p>
</aside>
<a class="header" href="print.html#logging" id="logging"><h2>Logging</h2></a>
<p>To make it easier to understand what is happening in our program,
we might want to add some log statements.
This is usually easy while writing your application.
But it will become super helpful when running this program again in half a year.</p>
<aside class="todo">
<p><strong>TODO:</strong>
<code>log</code> crate: macros with similar syntax to <code>println</code>
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/68">Issue #68</a></p>
</aside>
<aside class="todo">
<p><strong>TODO:</strong>
crate for actual log output – which one?
env_logger?
Link to <code>../in-depth/human-communication.html</code>
<a href="https://github.com/rust-lang-nursery/cli-wg/issues/68">Issue #68</a></p>
</aside>
<aside>
<p><strong>Aside:</strong>
Experience has shown that even mildly useful CLI programs can end up being used for years to come.
(Especially if they were meant as a temporary solution.)
If your application doesn’t work
and someone (e.g., you, in the future) needs to figure out why,
being able to pass <code>--verbose</code> to get additional log output
can make the difference between minutes and hours of debugging.</p>
</aside>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<p>Over the decades of people doing software development
one truth has been found:
Untested software rarely works.
(Many people would go so far and add
“Most tested software doesn’t work either.”
But we are all optimists here, right?)
So, to ensure that your program does what you expect it to do,
it is wise to test it.</p>
<p>One easy way to do that is
to write a <code>README</code> file
that describes what your program should do.
And when you feel ready to make a new release,
go through the <code>README</code> and ensure that
the behavior is still as expected.
You can make this a more rigorous exercise
by also writing down how your program should react to erroneous inputs.</p>
<p>Here’s another fancy idea:
Write that <code>README</code> before you write the code.</p>
<aside>
<p><strong>Aside:</strong>
Have a look at
<a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a> (TDD)
if you haven’t heard of it.</p>
</aside>
<a class="header" href="print.html#automated-testing" id="automated-testing"><h2>Automated testing</h2></a>
<p>Now, this is all fine and dandy,
but doing all of this manually?
That can take a lot of time.
At the same time,
many people have come to enjoy telling computers to do things for them.
Let’s talk about how to automate these tests.</p>
<p>Rust has a built-in test framework,
so let’s start by writing a first test:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
#}</code></pre></pre>
<p>You can put this snippet of code in pretty much any file
and <code>cargo test</code> will find
and run it.
The key here is the <code>#[test]</code> attribute.
It allows the build system to discover such functions
and run them as tests,
verifying that they don’t panic.</p>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong>
Make this test work.</p>
<p>You should end up with output like the following:</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>Now that we’ve seen <em>how</em> we can write tests,
we still need to figure out <em>what</em> to test.
As you’ve seen it’s fairly easy to write assertions
for functions.
But a CLI application is often more than one function!
Worse, it often deals with user input,
reads files,
and writes output.</p>
<a class="header" href="print.html#making-your-code-testable" id="making-your-code-testable"><h2>Making your code testable</h2></a>
<p>There are two complementary approaches to testing functionality:
Testing the small units that you build your complete application from,
these are called “unit tests”.
There is also testing the final application “from the outside”
called “black box tests” or “integration tests”.
Let’s begin with the first one.</p>
<p>To figure out what we should test,
let’s see what our program features are.
Mainly, <code>grrs</code> is supposed to print out the lines that match a given pattern.
So, let’s write unit tests for <em>exactly this</em>:
We want to ensure that our most important piece of logic works,
and we want to do it in a way that is not dependent
on any of the setup code we have around it
(that deals with CLI arguments, for example).</p>
<p>Going back to our <a href="../impl-draft.md">first implementation</a> of <code>grrs</code>,
we added this block of code to the <code>main</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
#}</code></pre></pre>
<p>Sadly, this is not very easy to test.
First off all, it’s in the main function, so we can’t easily call it.
This is easily fixed by moving this piece of code into a function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
#}</code></pre></pre>
<p>Now we can call this function in our test,
and see what its output is:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn find_a_match() {
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;);
    assert_eq!( // uhhhh
#}</code></pre></pre>
<p>Or… can we?
Right now, <code>find_matches</code> prints directly to <code>stdout</code>, i.e., the terminal.
We can’t easily capture this in a test!
This is a problem that often comes up
when writing tests after the implementation:
We have written a function that is firmly integrated
in the context it is used in.</p>
<aside class="note">
<p><strong>Note:</strong>
This is totally fine when writing small CLI applications.
There’s no need to make everything testable!
It is important to think about
which parts of your code you might want to write unit tests for, however.
While we’ll see that it’s easy to change this function to be testable,
this is not always the case.</p>
</aside>
<p>Alright, how can we make this testable?
We’ll need to capture the output somehow.
Rust’s standard library has some neat abstractions
for dealing with I/O (input/output)
and we’ll make use of one called <a href="https://doc.rust-lang.org/1.28.0/std/io/trait.Write.html"><code>std::io::Write</code></a>.
This is a trait that abstract over things we can write to,
which includes strings but also <code>stdout</code>.</p>
<aside class="note">
<p><strong>Note:</strong>
We could also make this function return a <code>String</code>,
but that would change the behavior.
Instead of writing to the terminal directly,
it would then collect everything into a string,
and dump all the results in one go at the end.</p>
</aside>
<p>Let’s change our function to also accept a parameter <code>writer</code>
that implements <code>Write</code>.
In our test, we can then supply a simple string
to make assertions on.
Instead of <code>println!(…)</code> we can just use <code>writeln!(writer, …)</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn find_matches&lt;W: Write&gt;(content: &amp;str, pattern: &amp;str, writer: &amp;mut W) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, &quot;{}&quot;, line);
        }
    }
}
#}</code></pre></pre>
<p>Now we can test for the output:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;, &amp;mut result);
    assert_eq!(result, b&quot;lorem ipsum\n&quot;);
}
#}</code></pre></pre>
<p>To now use this in our application code,
we have to change the call to <code>find_matches</code> in <code>main</code>
by adding <a href="https://doc.rust-lang.org/1.28.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> as the third parameter.</p>
<aside class="note">
<p><strong>Note:</strong>
Since <code>stdout</code> expects bytes (not strings),
we use <code>std::io::Write</code>, instead of <code>std::fmt::Write</code>.
As a result,
we give an empty vector as “writer” in our tests
(its type will be inferred to by <code>Vec&lt;u8&gt;</code>),
and in the <code>assert_eq!</code> we use a <code>b&quot;foo&quot;</code>
instead of a regular string.</p>
</aside>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong>
<a href="https://doc.rust-lang.org/1.28.0/std/macro.writeln.html"><code>writeln!</code></a> returns an <a href="https://doc.rust-lang.org/1.28.0/std/io/type.Result.html"><code>io::Result</code></a>. Add error handling to <code>find_matches</code>.</p>
</aside>
<p>We’ve just seen how to make this piece of code easily testable.
We have</p>
<ol>
<li>identified one of the core pieces of our application,</li>
<li>put it into its own function,</li>
<li>and made it more flexible.</li>
</ol>
<p>Even though the goal was to make it testable,
the result we ended up with
is actually a very idiomatic and reusable piece of Rust code.
That’s awesome!</p>
<a class="header" href="print.html#splitting-your-code-into-library-and-binary-targets" id="splitting-your-code-into-library-and-binary-targets"><h2>Splitting your code into library and binary targets</h2></a>
<p>There’s one more step we can go here.
So far we’ve put everything we wrote into the <code>src/main.rs</code> file.
This means our current project produces a single binary.
But we can also make our code available as a library, like this:</p>
<ol>
<li>Put the <code>find_matches</code> function into a new <code>src/lib.rs</code>.</li>
<li>Add a <code>pub</code> in front of the <code>fn</code> (so it’s <code>pub fn find_matches</code>)
to make it something that users of our library can access.</li>
<li>Remove <code>find_matches</code> from <code>src/main.rs</code>,
and instead add an <code>extern crate grrs;</code> on top.</li>
<li>In the <code>fn main</code>, prepend the call to <code>find_matches</code> with <code>grrs::</code>,
so it’s now <code>grrs::find_matches(…)</code>.
This means it uses the function from the library we just wrote!</li>
</ol>
<p>The way Rust deals with projects is quite flexible
and it’s a good idea to think about
what to put into the library part of your crate early on.
You can for example think about writing a library
for your application-specific logic first
and then use it in your CLI just like any other library.
Or, if your project has multiple binaries,
you can put the common functionality into the library part of that crate.</p>
<aside class="note">
<p><strong>Note:</strong>
Speaking of putting everything into a <code>src/main.rs</code>:
If we can continue to do that,
it’ll become difficult to read.
<a href="https://doc.rust-lang.org/book/2018-edition/ch07-00-modules.html">The module system</a>
can help you structure and organize your code.</p>
</aside>
<a class="header" href="print.html#testing-cli-applications-by-running-them" id="testing-cli-applications-by-running-them"><h2>Testing CLI applications by running them</h2></a>
<p>Thus far, we’ve gone out of our way
to test the <em>business logic</em> of our application,
which turned out to be the <code>find_matches</code> function.
This is very valuable
and is a great first step
towards a well-tested code base.
(Usually, these kinds of tests are called “unit tests”.)</p>
<p>There is a lot of code we aren’t testing, though:
Everything that we wrote to deal with the outside world!
Imagine you wrote the main function,
but accidentally left in a hard-coded string
instead of using the argument of the user-supplied path.
We should write tests for that, too!
(This level of testing is often called
“integration testing”, or “system testing”.)</p>
<p>At its core,
we are still writing functions
and annotate them with <code>#[test]</code>.
It’s just a matter of what we do inside these functions.
For example, we’ll want to use the main binary of our project,
and run it like a regular program.
We will also put these tests into a new file in a new directory:
<code>tests/cli.rs</code>.</p>
<aside>
<p><strong>Aside:</strong>
By convention,
<code>cargo</code> will look for integration tests in the <code>tests/</code> directory.
Similarly,
it will look for benchmarks in <code>benches/</code>,
and examples in <code>examples</code>/.
These conventions also extend to your main source code:
libraries have a <code>src/lib.rs</code> file,
the main binary is <code>src/main.rs</code>,
or, if there are multiple binaries,
cargo expects them to be in <code>src/bin/&lt;name&gt;.rs</code>.
Following these conventions will make your code base more discoverable
by people used to reading Rust code.</p>
</aside>
<p>To recall,
<code>grrs</code> is a small tool that searches for a string in a file.
We have previously tested that we can find a match.
Let’s think about what other functionality we can test.</p>
<p>Here is what I came up with.</p>
<ul>
<li>What happens when the file doesn’t exist?</li>
<li>What is the output when there is no match?</li>
<li>Does our program exit with an error when we forget one (or both) arguments?</li>
</ul>
<p>These are all valid test cases.
Additionally,
we should also include one test case
for the “happy path”,
i.e., we found at least one match
and we print it.</p>
<p>To make these kinds of tests easier,
we’re going to use the <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> crate.
It has a bunch of neat helpers
that allow us to run our main binary
and see how it behaves.
Further,
we’ll also add the <a href="https://docs.rs/predicates"><code>predicates</code></a> crate
which helps us write assertions
that <code>assert_cmd</code> can test against
(and that have great error messages).</p>
<p>This sounds like a lot of setup.
Nevertheless --
let’s dive right in
and create our <code>tests/cli.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate assert_cmd;
extern crate predicates;

use std::process::Command;  // Run programs
use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
    let mut cmd = Command::main_binary()?;
    cmd.arg(&quot;foobar&quot;)
        .arg(&quot;test/file/doesnt/exist&quot;);
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;No such file or directory&quot;));

    Ok(())
}
#}</code></pre></pre>
<p>You can run this test with
<code>cargo test</code>,
just the tests we wrote above.
It might take a little longer the first time,
as <code>Command::main_binary()</code> needs to compile your main binary.</p>
<aside class="todo">
<p><strong>TODO:</strong></p>
<ul>
<li>Talk about generating temp dirs with demo files.</li>
<li>Write a <em>useful</em> test asserting clap’s output (not to little, no too much; we don’t want to test all of clap after all)</li>
</ul>
<p><a href="https://github.com/rust-lang-nursery/cli-wg/issues/72">Issue #72</a></p>
</aside>
<a class="header" href="print.html#packaging-and-distributing-a-rust-tool" id="packaging-and-distributing-a-rust-tool"><h1>Packaging and distributing a Rust tool</h1></a>
<p>If you feel confident that your program is ready to for other people to use,
it is time to package and release it!</p>
<p>There are a few approaches,
and we’ll look at three of them
from “quickest to set up” to “most convenient for users”.</p>
<a class="header" href="print.html#quickest-cargo-publish" id="quickest-cargo-publish"><h2>Quickest: <code>cargo publish</code></h2></a>
<p>The easiest way to publish your app is with cargo.
Do you remember how we added external dependencies to our project?
Cargo downloaded them from its default “crate registry”, <a href="https://crates.io/">crates.io</a>.
With <code>cargo publish</code>,
you too can publish crates to <a href="https://crates.io/">crates.io</a>.
And this works for all crates,
including those with binary targets.</p>
<p>Publishing a crate to <a href="https://crates.io/">crates.io</a> is pretty straight-forward:
If you haven’t already, create an account on <a href="https://crates.io/">crates.io</a>.
Currently, this is done via authorizing you on Github,
so you’ll need to have a Github account
(and be logged in there).
Next, you need to log in using cargo.
For that, go to your
<a href="https://crates.io/me">crates.io account page</a>,
create a new token,
and then run <code>cargo login &lt;your-new-token&gt;</code>.
You only need to do this once per computer.
You can learn more about this
in cargo’s <a href="https://doc.rust-lang.org/1.30.0/cargo/reference/publishing.html">publishing guide</a>.</p>
<p>Now that cargo as well as crates.io know you,
you can publish crates.
Before you hastily go ahead and publish a new crate version,
it’s a good idea to open your <code>Cargo.toml</code> once more
and make sure you added a the necessary metadata.
You can find all the possible fields you can set
in the documentation for <a href="https://doc.rust-lang.org/1.30.0/cargo/reference/manifest.html">cargo’s manifest format</a>.
Here’s a quick overview of some common entries:</p>
<pre><code class="language-toml">[package]
name = &quot;grrs&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;your@email.com&gt;&quot;]
license = &quot;MIT OR Apache-2.0&quot;
description = &quot;A tool to search files&quot;
readme = &quot;README.md&quot;
homepage = &quot;https://github.com/you/grrs&quot;
repository = &quot;https://github.com/you/grrs&quot;
keywords = [&quot;cli&quot;, &quot;search&quot;, &quot;demo&quot;]
categories = [&quot;command-line-utilities&quot;]
</code></pre>
<aside class="note">
<p><strong>Note:</strong>
This example includes the mandatory license field
with a common choice for Rust projects:
The same license that is also used for the compiler itself.
It also refers to a <code>README.md</code> file.
It should include a quick description of what your project is about,
and will be included not only on the crates.io page of your crate,
but also what Github shows by default on repository pages.</p>
</aside>
<a class="header" href="print.html#how-to-install-a-binary-from-cratesio" id="how-to-install-a-binary-from-cratesio"><h3>How to install a binary from crates.io</h3></a>
<p>Now that we’ve seen how to publish a crate to crates.io,
you might be wondering how to install it.
In contrast to libraries,
that cargo will download and compile for you
when you run <code>cargo build</code> (or a similar command),
you’ll need to tell it to explicitly install binaries.</p>
<p>This is done using
<code>cargo install &lt;crate-name&gt;</code>.
It will by default download the crate,
compile all the binary targets it contains
(in “release” mode, so it might take a while)
and copy them into the <code>~/.cargo/bin/</code> directory.
(Make sure that your shell knows to looks there for binaries!)</p>
<p>It’s also possible to
install crates from git repositories,
only install specific binaries of a crate,
and specify and alternative directory to install them to.
Have a look at <code>cargo install --help</code> for details.</p>
<a class="header" href="print.html#when-to-use-it" id="when-to-use-it"><h3>When to use it</h3></a>
<p><code>cargo install</code> is a simple way to publish a binary crate.
It’s very convenient for Rust developers to use,
but has some significant downsides:
Since it will always compile your source from scratch,
users of your tool will need to have
Rust, cargo, and all other system dependencies your project requires
installed on their machine.
Compiling large Rust code bases can also take some time.</p>
<p>Furthermore, there is no simple way to update tools installed with cargo:
User will need to run <code>cargo install</code> again at some point,
and pass the <code>--force</code> flag to overwrite the old binaries.
This is a <a href="https://github.com/rust-lang/cargo/issues/2082">missing feature</a>
and there are subcommands <a href="https://crates.io/crates/cargo-update">like this one</a>
you can install to add that,
though.</p>
<p>It’s best to use this for distributing tools
that are targeted at other Rust developers.
For example:
A lot of cargo subcommands
like <code>cargo-tree</code> or <code>cargo-outdated</code>
can be installed with it.</p>
<a class="header" href="print.html#distributing-binaries" id="distributing-binaries"><h2>Distributing binaries</h2></a>
<p>Rust is a language that compiles to native code
and by default statically links all dependencies.
When you run <code>cargo build</code>
on your project that contains a binary called <code>grrs</code>,
you’ll end up with a single binary file called <code>grrs</code>,
that has no (or only very few)
external dependencies.
That means,
you take that one file
and send it to people running the same operating system as you,
and they’ll be able to run it.</p>
<p>This is very powerful!
It also works around two of the downsides we just saw for <code>cargo install</code>:
There is no need to have Rust installed on the user’s machine,
and instead of it taking a minute to compile,
they can instantly run the binary.</p>
<p>As we’ve seen,
<code>cargo build</code> <em>already</em> builds binaries for us.
The only issue is,
those are not guaranteed to work on all platforms.
If you run <code>cargo build</code> on your Windows machine,
you won’t get a binary that works on a Mac by default.
Is there a way to generate these binaries
for all the interesting platforms
automatically?</p>
<a class="header" href="print.html#building-binary-releases-on-ci" id="building-binary-releases-on-ci"><h3>Building binary releases on CI</h3></a>
<p>If your tool is open source,
and hosted on Github,
it’s quite easy to set up a free CI (continuous integration) service
like <a href="https://travis-ci.com/">Travis CI</a>.
(There are other services that also work on other platforms, but Travis is very popular.)
This basically runs setup commands
in a virtual machine
each time you push changes to your repository.
What those commands are,
and the types of machines they run on,
is configurable.
For example:
A good idea is to run <code>cargo test</code>
on a machine with Rust and some common build tools installed.
If this fails,
you know there are issues in the most recent changes.</p>
<p>We can also use this
to build binaries and upload them to Github!
Indeed, if we run
<code>cargo build --release</code>
and upload the binary somewhere,
we should be all set, right?
Not quite.
We still need to make sure the binaries we build
are compatible with as many systems as possible.
For example,
on Linux we can compile not for the current system,
but instead for the <code>x86_64-unknown-linux-musl</code> target,
to not depend on default system libraries.
On macOS, we can set <code>MACOSX_DEPLOYMENT_TARGET</code> to <code>10.7</code>
to only depend on system features present in versions 10.7 and older.</p>
<p>You can see one example of building binaries using this approach
<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">here</a> for Linux and macOS
and <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">here</a> for Windows (using AppVeyor).</p>
<p>Another way is to use pre-built (Docker) images
that contain all the tools we need
to build binaries.
This allows us to easily target more exotic platforms, too.
The <a href="https://github.com/japaric/trust">trust</a> project contains
scripts that you can include in your project
as well as instructions on how to set this up.
It also includes support for Windows using AppVeyor.</p>
<p>If you’d rather set this up locally
and generate the release files on your on machine,
still have a look at trust.
It uses <a href="https://github.com/rust-embedded/cross">cross</a> internally,
which works similar to cargo
but forwards commands to a cargo process inside a Docker container.
The definitions of the images are also available in
<a href="https://github.com/rust-embedded/cross">cross’ repository</a>.</p>
<a class="header" href="print.html#how-to-install-these-binaries" id="how-to-install-these-binaries"><h3>How to install these binaries</h3></a>
<p>You point your users to your release page
that might look something <a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">like this one</a>,
and they can download the artifacts we’ve just created.
The release artifacts we’ve just generated are nothing special:
At the end, they are just archive files that contain our binaries!
This means that users of your tool
can download them with their browser,
extract them (often happens automatically),
and copy the binaries to a place they like.</p>
<p>This does require some experience with manually “installing” programs,
so you want to add a section to your README file
on how to install this program.</p>
<aside class="note">
<p><strong>Note:</strong>
If you used <a href="https://github.com/japaric/trust">trust</a> to build your binaries and add them to Github releases,
you can also tell people to run
<code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>
if you think that makes it easier.</p>
</aside>
<a class="header" href="print.html#when-to-use-it-1" id="when-to-use-it-1"><h3>When to use it</h3></a>
<p>Having binary releases is a good idea in general,
there’s hardly any downside to it.
It does not solve the problem of users having to manually
install and update
your tools,
but they can quickly get the latest releases version
without the need to install Rust.</p>
<a class="header" href="print.html#what-to-package-in-addition-to-your-binaries" id="what-to-package-in-addition-to-your-binaries"><h3>What to package in addition to your binaries</h3></a>
<p>Right now,
when a user downloads our release builds,
they will get a <code>.tar.gz</code> file
that only contains binary files.
So, in our example project,
they will just get a single <code>grrs</code> file they can run.
But there are some more files we already have in our repository
that they might want to have.
The README file that tells them how to use this tool,
and the license file(s),
for example.
Since we already have them,
they are easy to add.</p>
<p>There are some more interesting file
that make sense especially for command-line tools,
though:
How about we also ship a man page in addition to that README file,
and config files that add completions of the possible flags to your shell?
You can write these by hand,
but <em>clap</em>, the argument parsing library we use
(which structopt builds upon)
has a way to generate all these files for us.
See <a href="../../in-depth/docs.md">this in-depth chapter</a>
for more details.</p>
<a class="header" href="print.html#getting-your-app-into-package-repositories" id="getting-your-app-into-package-repositories"><h2>Getting your app into package repositories</h2></a>
<p>Both approaches we’ve seen so far
are not how you typically install software on your machine.
Especially command-line tools
you install using global package managers
on most operating systems.
The advantages for users are quite obvious:
There is no need to think about how to install your program,
if it can be installed the same way as they install the other tools.
These package managers also allow users to update their programs
when a new version is available.</p>
<p>Sadly, supporting different systems means
you’ll have to look at how these different systems work.
For some it might be as easy as adding a file to your repository
(e.g. adding a Formula file like <a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">this</a> for macOS’s <code>brew</code>),
but for others you’ll often need to send in patches yourself
and add your tool to their repositories.
There are helpful tools like
<a href="https://crates.io/crates/cargo-rpm">cargo-rpm</a> and
<a href="https://crates.io/crates/cargo-deb">cargo-deb</a>,
but describing how they work
and how to correctly package your tool
for those different systems is beyond the scope of this chapter.</p>
<p>Instead,
let’s have a look at a tool that is written in Rust
and that is available in many different package managers.</p>
<a class="header" href="print.html#an-example-ripgrep" id="an-example-ripgrep"><h3>An example: ripgrep</h3></a>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> is an alternative to <code>grep</code>/<code>ack</code>/<code>ag</code> and is written in Rust.
It’s quite successful and is packaged for many operating systems:
Just look at <a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">the “Installation” section</a> of its README!</p>
<p>Note that it list a few different options how you can install it:
It starts with a link to the Github releases
which contain the binaries so you can download them directly;
then it lists how to install it using a bunch of different package manages;
finally, you can also install it using <code>cargo install</code>.</p>
<p>This seems like a very good idea:
Don’t pick and choose one of the approaches presented here,
but start with <code>cargo installs</code>,
add binary releases,
and finally start distributing your tool using system package managers.</p>
<a class="header" href="print.html#in-depth-topics" id="in-depth-topics"><h1>In-depth topics</h1></a>
<a class="header" href="print.html#signal-handling" id="signal-handling"><h1>Signal handling</h1></a>
<a class="header" href="print.html#using-config-files" id="using-config-files"><h1>Using config files</h1></a>
<p>Dealing with configurations can be annoying
especially if you support multiple operating systems
which all have their own places
for short- and long-term files.</p>
<p>There are multiple solutions to this,
some being more low-level than others.</p>
<p>The crate easiest to use is <code>confy</code>.
It asks you for the name of your application
and requires you to specify the config layout
via a <code>struct</code> (that is <code>Serialize</code>, <code>Deserialize</code>)
and it will figure out the rest!</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: ConfyConfig = confy::load(&quot;my_app&quot;)?;
    println!(&quot;{:#?}&quot;, cfg);
    Ok(())
}
</code></pre></pre>
<p>This is incredibly easy to use
for which you of course surrender configurability.
But if a simple config is all you want,
this crate might be for you!</p>
<a class="header" href="print.html#configuration-environments" id="configuration-environments"><h2>Configuration environments</h2></a>
<aside class="todo">
<p><strong>TODO</strong></p>
<ol>
<li>Evaluate crates that exist</li>
<li>Cli-args + multiple configs + env variables</li>
<li>Can <code>configure</code> do all this? Is there a nice wrapper around it?</li>
</ol>
</aside><a class="header" href="print.html#exit-codes" id="exit-codes"><h1>Exit codes</h1></a>
<p>A program doesn’t always succeed.
And when an error occurs,
you should make sure to emit the necessary information correctly.
In addition to
<a href="./in-depth/human-communication.html">telling the user about errors</a>,
on most systems,
when a process exits,
it also emits an exit code
(an integer between 0 and 255 is compatible with most platforms).
You should try to emit the correct code
for your program’s state.
For example,
in the ideal case when your program succeeds,
it should exit with <code>0</code>.</p>
<p>When an error occurs, it gets a bit more complicated, though.
In the wild,
a lot of tools exit with <code>1</code> when a general failure ocurred.
Currently, Rust set and exit code of <code>101</code> when the process panicked.
Beyond that, people have done many things in their programs.</p>
<p>So, what to do?
The BSD ecosystem has collected a common definition for their exit codes
(you can find them <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">here</a>).
The Rust library <a href="https://crates.io/crates/exitcode"><code>exitcode</code></a> provides these same codes,
ready to be used in your application.
Please see its API documentation for the possible values to use.</p>
<p>One way to use it is like this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // ...actual work...
    match result {
        Ok(_) =&gt; {
            println!(&quot;Done!&quot;);
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}
</code></pre></pre>
<a class="header" href="print.html#communicating-with-humans" id="communicating-with-humans"><h1>Communicating with humans</h1></a>
<a class="header" href="print.html#when-everything-is-fine" id="when-everything-is-fine"><h2>When everything is fine</h2></a>
<p>It is useful to report on the application’s progress
even when everything is fine.
Try to be informative and concise in these messages.
Don’t use overly technical terms in the logs.
Remember:
the application is not crashing
so there’s no reason for users to look up errors.</p>
<p>Most importantly,
be consistent in the style of communication.
Use the same prefixes and sentence structure
to make the logs easily skimmable.</p>
<p>Try to let your application output tell a story
about what it’s doing
and how it impacts the user.
This can involve showing a timeline of steps involved
or even a progress bar and indicator for long running actions.
The user should at no point
get the feeling that the application is doing something mysterious
that they cannot follow.</p>
<a class="header" href="print.html#when-its-hard-to-tell-whats-going-on" id="when-its-hard-to-tell-whats-going-on"><h2>When it’s hard to tell what’s going on</h2></a>
<p>When communicating non-nominal state it’s important to be consistent.
A heavily logging application that doesn’t follow strict logging levels
provides the same amount, or even less information
than a non-logging application.</p>
<p>Because of this it’s important to define the severity of events
and messages that are related to it;
then use consistent log levels for them.
This way users can select the amount of logging themselves
via <code>--verbose</code> flags
or environment variables (like <code>RUST_LOG</code>).</p>
<p>The commonly used <code>log</code> crate
<a href="https://docs.rs/log/0.4.4/log/enum.Level.html">defines</a> the following levels
(ordered by increasing severity):</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>It’s a good idea to think of <em>info</em> as the default log level.
Use it for, well, informative output.
(Some applications that lean towards a more quiet output style
might only show warnings and errors by default.)</p>
<p>Additionally it’s always a good idea to use similar prefixes
and sentence structure across log messages,
making it easy to <code>grep</code> or filter for them.
A message should provide enough context by itself
to be useful in a filtered log
while not being <em>too</em> verbose at the same time.</p>
<a class="header" href="print.html#example-log-statements" id="example-log-statements"><h3>Example log statements</h3></a>
<pre><code>error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code>=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p>The following log output is taken from <a href="https://crates.io/crates/wasm-pack">wasm-pack</a>:</p>
<pre><code> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<a class="header" href="print.html#when-panicking" id="when-panicking"><h2>When panicking</h2></a>
<p>One aspect often forgotten is that
your program also outputs something when it crashes.
In Rust, “crashes” are most often “panics”
(i.e., “controlled crashing”
in contrast to “the operating system killed the process”).
By default,
when a panic occurs,
a “panic handler” will print some information to the console.</p>
<p>For example,
if you create a new binary project
with <code>cargo new --bin foo</code>
and replace the content of <code>fn main</code> with <code>panic!(&quot;Hello World&quot;)</code>,
you get this when you run your program:</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This is useful information to you, the developer.
(Surprise: the program crashed because of line 2 in your <code>main.rs</code> file).
But for a user who doesn’t even have access to the source code,
this is not very valuable.
In fact, it most likely is just confusing.
That’s why it’s a good idea to add a custom panic handler,
that provides a bit more end-user focussed output.</p>
<p>One library that does just that is called <a href="https://crates.io/crates/human-panic">human-panic</a>.
To add it to your CLI project,
you import it
and call the <code>setup_panic!()</code> macro
at the beginning of your <code>main</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!(&quot;Hello world&quot;)
}
</code></pre></pre>
<p>This will now show a very friendly message,
and tells the user what they can do:</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at &quot;/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml&quot;. Submit an issue or email with the subject of &quot;foo Crash Report&quot; and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<a class="header" href="print.html#communicating-with-machines" id="communicating-with-machines"><h1>Communicating with machines</h1></a>
<p>The power of command-line tools really comes to shine
when you are able to combine them.
This is not a new idea:
In fact, this is a sentence from the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a>:</p>
<blockquote>
<p>Expect the output of every program to become the input to another, as yet unknown, program.</p>
</blockquote>
<p>If our programs fulfil this expectation,
our users will be happy.
To make sure this works well,
we should provide not just pretty output for humans,
but also a version tailored to what other programs need.
Let’s see how we can do this.</p>
<a class="header" href="print.html#whos-reading-this" id="whos-reading-this"><h2>Who’s reading this?</h2></a>
<p>The first question to ask is:
Is our output for a human in front of a colorful terminal,
or for another program?
To answer this,
we can use a crate like <a href="https://crates.io/crates/atty">atty</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use atty::Stream;

if atty::is(Stream::Stdout) {
    println!(&quot;I'm a terminal&quot;);
} else {
    println!(&quot;I'm not&quot;);
}
#}</code></pre></pre>
<p>Depending on who will read our output,
we can then add extra information.
Humans tend to like colors,
for example,
so if I run <code>ls</code> in a random Rust project,
I’ll get something like</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>where the last three words are in blue (to show they are folders).
If I were to pipe this to a file,
or a program like <code>cat</code>,
<code>ls</code> will adapt its output.
Instead of using columns that fit my terminal window
it will print every entry on its own line.
It will also not emit any colors.</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<a class="header" href="print.html#easy-output-formats-for-machines" id="easy-output-formats-for-machines"><h2>Easy output formats for machines</h2></a>
<p>Historically,
the only type of output command-line tools produced were strings.
This is usually fine for people in front of terminals,
who are able to read text
and reason about its meaning.
Other programs usually don’t have that ability, though:
The only way for them to understand the output of a tool
like <code>ls</code>
is if the author of the program included a parser
that happens to work for whatever <code>ls</code> outputs.</p>
<p>This often means
that output was limited to what is easy to parse.
Formats like TSV,
where each record is on its own line,
and each line contains tab-separated content,
are very popular.
These simple formats based on lines of text
allow tools like <code>grep</code>
to be used on the output of tools like <code>ls</code>.
<code>| grep Cargo</code> doesn’t care if your lines are from <code>ls</code> or file,
it will just filter line by line.</p>
<p>The downside of this is that you can’t use
an easy <code>grep</code> invocation to filter all the directories that <code>ls</code> gave you.</p>
<a class="header" href="print.html#json-output-for-machines" id="json-output-for-machines"><h2>JSON output for machines</h2></a>
<aside class="todo">
<p><strong>TODO:</strong>
Talk about how outputting lines of JSON documents is an approach some tools take.
(see <a href="https://github.com/rust-lang-nursery/cli-wg/issues/95">#95</a>)</p>
</aside>
<a class="header" href="print.html#how-to-deal-with-input-piped-into-us" id="how-to-deal-with-input-piped-into-us"><h2>How to deal with input piped into us</h2></a>
<aside class="todo">
<p><strong>TODO:</strong>
Talk about how work with stdin
(see <a href="https://github.com/rust-lang-nursery/cli-wg/issues/95">#95</a>)</p>
</aside>
<a class="header" href="print.html#rendering-documentation-for-you-cli-apps" id="rendering-documentation-for-you-cli-apps"><h1>Rendering documentation for you CLI apps</h1></a>
<p>Documentation for CLIs usually consists of
a <code>--help</code> section in the command
and a manual (<code>man</code>) page.</p>
<p>Both can be automatically generated
when using <code>clap</code>,
via the <code>man</code> backend.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Clap)]
pub struct Head {
    /// file to load
    #[clap(parse(from_os_str))]
    pub file: PathBuf,
    /// how many lines to print
    #[clap(short = &quot;n&quot;, default_value = &quot;5&quot;)]
    pub count: usize,
}
#}</code></pre></pre>
<p>Secondly, you need to use a <code>build.rs</code>
to generate the manual file at compile-time
from the definition of your app
in code.</p>
<p>There are a few things to keep in mind
(such as how you want to package your binary)
but for now
we simply put the <code>man</code> file
next to our <code>src</code> folder.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate clap;
extern crate clap_generate;

#[path=&quot;src/cli.rs&quot;]
mod cli;

fn main() {
    use clap::IntoApp;
    let app = cli::Head::into_app();

    use clap_generate::gen_manuals;
    for man in gen_manuals(&amp;app) {
        let name = &quot;head.1&quot;;
        let mut out = fs::File::create(&quot;head.1&quot;).unwrap();
        use std::io::Write;
        out.write_all(man.render().as_bytes()).unwrap();
    }
}
</code></pre></pre>
<p>When you now compile your application
there will be a <code>head.1</code> file
in your project directory.</p>
<p>If you open that in <code>man</code>
you’ll be able to admire your free documentation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
